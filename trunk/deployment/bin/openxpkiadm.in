#!/usr/bin/perl
#
# Written by Martin Bartosch for the OpenXPKI project 2006
# Copyright (c) 2006 by The OpenXPKI Project
# $Revision: 80 $
#

our $VERSION = '0.9.$Revision: 244 $';
$VERSION =~ s{ \$ Revision: \s* (\d+) \s* \$ \z }{$1}xms;

use strict;
use warnings;
use English;
use Getopt::Long;
use Pod::Usage;
use File::Spec;
use File::Copy;

use OpenXPKI::VERSION;
use OpenXPKI::Server::Init;
use OpenXPKI::Server::Context qw( CTX );

# settings determined by openxpki-metaconf
my $prefix          = "[% dir.prefix %]";
my $exec_prefix     = "[% dir.exec_prefix %]";
my $template_prefix = "[% dir.templatedir %]";
my $sysconfdir      = "[% dir.sysconfdir %]";

my $openxpkiconfdir = "[% dir.openxpkiconfdir %]";
my $configfile      = "$openxpkiconfdir/config.xml";

# read configuration from deployed OpenXPKI instance
sub get_config {
    my $cfgfile = shift;
    return OpenXPKI::Server::Init::init(
	{
	    CONFIG => $cfgfile,
	    TASKS  => [ 
		'xml_config', 
		'i18n', 
		'log', 
		],
	});
}


sub initdb {
    my $args = shift;


    my $type = CTX('xml_config')->get_xpath (
	XPATH    => [ 'common/database/type' ],
	COUNTER  => [ 0 ]);
    
    print STDERR "Database type: $type\n";

    my @databases = qw( log );

    # SQLite needs special treatment: three databases instead of one must
    # be initialized
    if ($type =~ m{ SQLite }xms) {
	push @databases, 'workflow', 'backend';
    }

  DB:
    foreach my $db (@databases) {
	my $params = {};
	if ($db ne 'log') {
	    $params->{PURPOSE} = $db;
	}

	if (defined $params->{PURPOSE}) {
	    print STDERR "Setting up database '$db'\n";
	}
	my $dbi = OpenXPKI::Server::Init::get_dbi($params);

	eval { 
	    $dbi->connect() 
	};
	if ($EVAL_ERROR)
	{
	    print STDERR "ERROR: Could not connect to '$db' database\n";
	    return;
	}
	
	if ($args->{DRYRUN}) {
	    print $dbi->init_schema(MODE => 'DRYRUN') . "\n";
	    last DB;
	} else {
	    if ($args->{FORCE}) {
		print STDERR "ERROR: forced creation not yet implemented.\n";
		return;
	    }

	    eval {
		$dbi->init_schema();
	    };
	    if ($EVAL_ERROR) {
		print STDERR "ERROR: init_schema on '$db' failed (${EVAL_ERROR})\n";
		return;
	    }
	    print STDERR "Database '$db' initialized.\n";
	}
    }
    return 1;
}


sub deploy {
    my $args = shift;

    my $targetdir       = $args->{TARGETDIR};
    my $template_prefix = $args->{TEMPLATE_PREFIX};
    my $template        = $args->{TEMPLATE};

    if (! defined $targetdir || ($targetdir eq '')) {
	print STDERR "No target directory specified.\n";
	return;
    }

    if (! (-d $targetdir && -r $targetdir && -x $targetdir && -w $targetdir)) {
	print STDERR "Directory $targetdir does not exist or is not writable.\n";
	return;
    }

    print "Deploying OpenXPKI configuration file set.\n";
    print "Source template directory: $template_prefix\n";
    print "Template set:              $template\n";
    print "Target directory:          $targetdir\n";

    if ($args->{DRYRUN}) {
	return 1;
    }

    if (! -d $template_prefix) {
	print STDERR "ERROR: template directory $template_prefix not found\n";
	return;
    }

    foreach my $file (qw( openxpki.conf )) {
	my $srcfile = File::Spec->catfile($template_prefix, $template, $file);
	my $dstfile = File::Spec->catfile($targetdir, $file);

	if (-e $dstfile) {
	    if (! $args->{FORCE}) {
		print STDERR "ERROR: $dstfile already exists\n";
		return;
	    }
	    move($dstfile, $dstfile . '.last');
	}
	if (! -e $srcfile) {
	    print STDERR "ERROR: $srcfile not found\n";
	    return;
	}
	print "wrote $dstfile\n";
	copy($srcfile, $dstfile) or return;
    }

    # checking some necessary var directories
    # tmpdir
    # localedir
    # openxpkistatedir
    # openxpkisessiondir
    my $user = CTX('xml_config')->get_xpath (
	XPATH    => [ 'common/server/user' ],
	COUNTER  => [ 0 ]);

    my $group = CTX('xml_config')->get_xpath (
	XPATH    => [ 'common/server/group' ],
	COUNTER  => [ 0 ]);

    foreach my $dir (qw( 
        common/server/session_dir 
        common/i18n/locale_directory 
    )) {
	my $path;
	eval {
	    $path = CTX('xml_config')->get_xpath (
		XPATH    => [ $dir ],
		COUNTER  => [ 0 ]);
	};
	if (! defined $path || $EVAL_ERROR) {
	    print STDERR "ERROR: could not read '$dir' configuration value\n";
	    return;
	}
        if (! -d $path)
        {
            ## old autoconf supports @INSTALL@
            ## FIXME: do we need an absolute path here?
	    print STDERR "Directory $path does not exist, creating it.\n";
            if (system("install -d -m 750 -o $user -g $group $path") != 0) {
	        print STDERR "ERROR: directory for $path ($dir) could not be created\n";
	        return;
            }
        }
    }

    return 1;
}

###########################################################################

my %params;
GetOptions(\%params,
	   qw(
	      help|?
	      man
	      cfg|cfgfile|conf|config=s
              version
	      force
	      dryrun
              templatedir=s
              template=s
	      )) or pod2usage(-verbose => 0);

if ($params{version}) {
    my ($vol, $dir, $file) = File::Spec->splitpath($0);
    print "OpenXPKI Core Version: $OpenXPKI::VERSION::VERSION\n";
    print "$file Version: $VERSION\n";
    exit 0;
}

pod2usage(-exitstatus => 0, -verbose => 2) if $params{man};
pod2usage(-verbose => 1) if ($params{help});
if (scalar @ARGV < 1) {
    print STDERR "Usage: openxpkiadm [OPTIONS] COMMAND\n";
    exit 0;
}

if (defined $params{cfg}) {
    $configfile = $params{cfg};
}


###########################################################################

my $cmd = shift;

if ($cmd eq 'initdb') {
    if (! get_config($configfile)) {
	print STDERR "Could not obtain OpenXPKI instance configuration\n";
	exit 1;
    }
    if (! initdb(
	     {
		 DRYRUN => $params{dryrun},
		 FORCE  => $params{force},
	     })) {
	print STDERR "Could not initialize database.\n";
	exit 1;
    }
} elsif ($cmd eq 'deploy') {
    if (! get_config($configfile)) {
	print STDERR "Could not obtain OpenXPKI instance configuration\n";
	exit 1;
    }

    my $dir = shift;
    if (! defined $dir) {
	$dir = $openxpkiconfdir;
    }
    if ($params{templatedir}) {
	$template_prefix = $params{templatedir};
    }
    my $template = $params{template} || 'default';    
    
    if (! deploy(
	{
	    TEMPLATE_PREFIX => $template_prefix,
	    TEMPLATE    => $template,
	    TARGETDIR   => $dir,
	    FORCE       => $params{force},
	    DRYRUN      => $params{dryrun},
	})) {
	print STDERR "Could not deploy OpenXPKI instance.\n";
	exit 1;
    }
} else {
    print STDERR "Unknown command '$cmd'.\n";
    exit 1;
}

exit 0;

__END__

=head1 NAME

openxpkiadm - tool for management operations of OpenXPKI instances

=head1 USAGE

openxpkiadm [OPTIONS] COMMAND

 Options:
   --help                brief help message
   --man                 full documentation
   --config FILE         use configuration from FILE
   --force               Force operation (may be destructive)
   --dryrun              Don't change anything, just print what would be done
   --templatedir DIR     Use specified directory as base directory for templates
   --template TEMPLATE   Use specified template (defaults to 'default')

 Commands:
   deploy [DIR]          Deploy a new OpenXPKI installation
   initdb                Initialize database


=head1 ARGUMENTS

Available commands:

=over 8

=item B<deploy> [DIR]

Creates a new OpenXPKI server configuration file set in the specified 
directory (defaults to @sysconfdir@/openxpki if no directory is specified).
This command will not overwrite existing configuration files unless --force
is specified.

If the --templatedir argument is given the specified directory is used
as template base directory.

If --template is specified, its argument is used instead of 'default' for
the source of the templates used.


=item B<initdb>

Initializes the OpenXPKI database schema. Will not destroy existing data
unless called with --force.

=back


=head1 OPTIONS

=over 8

=item B<--help>

Print a brief help message and exits.

=item B<--man>

Prints the manual page and exits.

=item B<--config FILE>

Read configuration file FILE. Uses built-in default if not specified.

=item B<--version>

Print program version and exit.

=item B<--force>

Force execution of command.

WARNING: This may destroy existing data!

=item B<--dryrun>

Prints effects of a command without actually modifying anything.

=back

=head1 DESCRIPTION

B<openxpkiadm> is the administrative frontend for controlling the OpenXPKI
installation.

=over 8

NOTE: This script was customized to the paths specified during 
installation.
You will have to modify this script to reflect any changes to the 
installation directories.

The openxpkiadm script returns a 0 exit value on success, and >0 if  an
error occurs.

=back

