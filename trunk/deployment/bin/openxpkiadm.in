#!/usr/bin/perl
#
# Written by Martin Bartosch for the OpenXPKI project 2006
# Copyright (c) 2006 by The OpenXPKI Project
# $Revision: 80 $
#

our $VERSION = '0.9.$Revision: 244 $';
$VERSION =~ s{ \$ Revision: \s* (\d+) \s* \$ \z }{$1}xms;

use strict;
use warnings;
use English;
use Getopt::Long;
use Pod::Usage;
use File::Spec;
use File::Copy;
use File::Path;

# use Smart::Comments;

use OpenXPKI::VERSION;
use OpenXPKI::Server::Init;
use OpenXPKI::Server::Context qw( CTX );

# settings determined by openxpki-metaconf
my %config = (
    prefix          => "[% dir.prefix %]",
    exec_prefix     => "[% dir.exec_prefix %]",
    template_prefix => "[% dir.templatedir %]",
    sysconfdir      => "[% dir.sysconfdir %]",
    localedir       => "[% dir.localedir %]",
    openxpkiconfdir => "[% dir.openxpkiconfdir %]",
    );

my $configfile      = "$config{openxpkiconfdir}/config.xml";

# read configuration from deployed OpenXPKI instance
sub get_config {
    my $cfgfile = shift;
    return OpenXPKI::Server::Init::init(
	{
	    CONFIG => $cfgfile,
	    TASKS  => [ 
		'xml_config', 
		'i18n', 
		'log', 
		],
	});
}

sub initdb {
    my $args = shift;


    my $type = CTX('xml_config')->get_xpath (
	XPATH    => [ 'common/database/type' ],
	COUNTER  => [ 0 ]);
    
    print STDERR "Database type: $type\n";

    my @databases = qw( log );

    # SQLite needs special treatment: three databases instead of one must
    # be initialized
    if ($type =~ m{ SQLite }xms) {
	push @databases, 'workflow', 'backend';
    }

  DB:
    foreach my $db (@databases) {
	my $params = {};
	if ($db ne 'log') {
	    $params->{PURPOSE} = $db;
	}

	if (defined $params->{PURPOSE}) {
	    print STDERR "Setting up database '$db'\n";
	}
	my $dbi = OpenXPKI::Server::Init::get_dbi($params);

	eval { 
	    $dbi->connect() 
	};
	if ($EVAL_ERROR)
	{
	    print STDERR "ERROR: Could not connect to '$db' database\n";
	    return;
	}
	
	if ($args->{DRYRUN}) {
	    print $dbi->init_schema(MODE => 'DRYRUN') . "\n";
	    last DB;
	} else {
	    if ($args->{FORCE}) {
		print STDERR "ERROR: forced creation not yet implemented.\n";
		return;
	    }

	    eval {
		$dbi->init_schema();
	    };
	    if ($EVAL_ERROR) {
		print STDERR "ERROR: init_schema on '$db' failed (${EVAL_ERROR})\n";
		return;
	    }
	    print STDERR "Database '$db' initialized.\n";
	}
    }
    return 1;
}


sub deploy {
    my $args = shift;

    my $targetdir       = $args->{TARGETDIR};
    my $template_prefix = $args->{TEMPLATE_PREFIX};
    my $template        = $args->{TEMPLATE};

    if (! defined $targetdir || ($targetdir eq '')) {
	print STDERR "No target directory specified.\n";
	return;
    }

    if (! (-d $targetdir 
	   && -r $targetdir 
	   && -x $targetdir 
	   && -w $targetdir)) {
	print STDERR "Directory $targetdir does not exist or is not writable.\n";
	return;
    }

    print STDERR "Deploying OpenXPKI configuration file set.\n";
    print STDERR "Template set:              $template\n";
    print STDERR "Template source directory: $template_prefix\n";
    print STDERR "Target directory:          $targetdir\n";

    if ($args->{DRYRUN}) {
	return 1;
    }

    if (! -d $template_prefix) {
	print STDERR "ERROR: template directory $template_prefix not found\n";
	return;
    }

    my $srcfile = File::Spec->catfile($template_prefix, 
				      $template, 
				      'openxpki.conf');

    # 2006-06-21 Martin Bartosch:
    # The deployment procedure now will create a new meta configuration 
    # file from the one that is installed in the template directory.
    
    # determine new configuration file directory (below $targetdir)
    my @cmd;
    @cmd = (
	'openxpki-metaconf',
	'--config', qq( $srcfile ),
	'--setcfg', "dir.prefix='$targetdir'",
	'--getcfg', 'dir.openxpkiconfdir',
	);
    
    my $cmd = join(' ', @cmd);
    my $openxpkiconfdir = `$cmd`;
    chomp($openxpkiconfdir);
    
    ### $openxpkiconfdir
    if (! -d $openxpkiconfdir) {
	if (! mkpath($openxpkiconfdir, 1, 0750)) {
	    print STDERR "Could not create configuration directory $openxpkiconfdir\n";
	    return;
	}
    }
    
    my $dstfile = File::Spec->catfile($openxpkiconfdir, 'openxpki.conf');
    
    if (-e $dstfile) {
	if (! $args->{FORCE}) {
	    print STDERR "ERROR: $dstfile already exists\n";
	    return;
	}
	move($dstfile, $dstfile . '.last');
    }

    if (! -e $srcfile) {
	print STDERR "ERROR: $srcfile not found\n";
	return;
    }

    # the new configuration file will reference two types of files/dirs:
    # - files/dirs that are specific for this particular deployment
    #   (e. g. configuration, log files, server socket...)
    # - files/dirs that are shared among ALL installed instances
    #   (e. g. locales)
    #
    
    ### $config{localedir}
    @cmd = (
	'openxpki-metaconf',
	'--config', qq( $srcfile ),
	'--writecfg', qq( $dstfile ),
	'--setcfg', "dir.prefix='$targetdir'",
	'--setcfg', "dir.localedir='$config{localedir}'"
	);
    
    if (system(join(' ', @cmd)) != 0) {
	print STDERR "ERROR: could not deploy target configuration file $dstfile\n";
	return;
    }
    
    print STDERR "wrote $dstfile\n";

    return 1;
}

###########################################################################

my %params;
GetOptions(\%params,
	   qw(
	      help|?
	      man
	      cfg|cfgfile|conf|config=s
              version
	      force
	      dryrun
              templatedir=s
              template=s
	      )) or pod2usage(-verbose => 0);

if ($params{version}) {
    my ($vol, $dir, $file) = File::Spec->splitpath($0);
    print "OpenXPKI Core Version: $OpenXPKI::VERSION::VERSION\n";
    print "$file Version: $VERSION\n";
    exit 0;
}

pod2usage(-exitstatus => 0, -verbose => 2) if $params{man};
pod2usage(-verbose => 1) if ($params{help});
if (scalar @ARGV < 1) {
    print STDERR "Usage: openxpkiadm [OPTIONS] COMMAND\n";
    exit 0;
}

if (defined $params{cfg}) {
    $configfile = $params{cfg};
}


###########################################################################

my $cmd = shift;

if ($cmd eq 'initdb') {
    if (! get_config($configfile)) {
	print STDERR "Could not obtain OpenXPKI instance configuration\n";
	exit 1;
    }
    if (! initdb(
	     {
		 DRYRUN => $params{dryrun},
		 FORCE  => $params{force},
	     })) {
	print STDERR "Could not initialize database.\n";
	exit 1;
    }
    exit 0;
} 

if ($cmd eq 'deploy') {
    if (! get_config($configfile)) {
	print STDERR "Could not obtain OpenXPKI instance configuration\n";
	exit 1;
    }

    my $dir = shift;
    if (! defined $dir) {
	$dir = $config{openxpkiconfdir};
    }
    if ($params{templatedir}) {
	$config{template_prefix} = $params{templatedir};
    }
    my $template = $params{template} || 'default';    
    
    if (! deploy(
	{
	    TEMPLATE_PREFIX => $config{template_prefix},
	    TEMPLATE    => $template,
	    TARGETDIR   => File::Spec->rel2abs($dir),
	    FORCE       => $params{force},
	    DRYRUN      => $params{dryrun},
	})) {
	print STDERR "Could not deploy OpenXPKI instance.\n";
	exit 1;
    }

    print STDERR "OpenXPKI instance successfully deployed to $dir.\n";
    print STDERR "You may now want to run\n\n";
    print STDERR "cd $dir\n";
    print STDERR "openxpki-configure\n";

    exit 0;
} 

print STDERR "Unknown command '$cmd'.\n";
exit 1;

__END__

=head1 NAME

openxpkiadm - tool for management operations of OpenXPKI instances

=head1 USAGE

openxpkiadm [OPTIONS] COMMAND

 Options:
   --help                brief help message
   --man                 full documentation
   --config FILE         use configuration from FILE
   --force               Force operation (may be destructive)
   --dryrun              Don't change anything, just print what would be done
   --templatedir DIR     Use specified directory as base directory for templates
   --template TEMPLATE   Use specified template (defaults to 'default')

 Commands:
   deploy [DIR]          Deploy a new OpenXPKI installation
   initdb                Initialize database


=head1 ARGUMENTS

Available commands:

=over 8

=item B<deploy> [DIR]

Creates a new OpenXPKI server configuration file set in the specified 
directory (defaults to [% dir.openxpkiconfdir %] if no directory is 
specified).
This command will not overwrite existing configuration files unless --force
is specified.

If the --templatedir argument is given the specified directory is used
as template base directory.

If --template is specified, its argument is used instead of 'default' for
the source of the templates used.


=item B<initdb>

Initializes the OpenXPKI database schema. Will not destroy existing data
unless called with --force.

=back


=head1 OPTIONS

=over 8

=item B<--help>

Print a brief help message and exits.

=item B<--man>

Prints the manual page and exits.

=item B<--config FILE>

Read configuration file FILE. Uses built-in default if not specified.

=item B<--version>

Print program version and exit.

=item B<--force>

Force execution of command.

WARNING: This may destroy existing data!

=item B<--dryrun>

Prints effects of a command without actually modifying anything.

=back

=head1 DESCRIPTION

B<openxpkiadm> is the administrative frontend for controlling the OpenXPKI
installation.

=over 8

NOTE: This script was customized to the paths specified during 
installation.
You will have to modify this script to reflect any changes to the 
installation directories.

The openxpkiadm script returns a 0 exit value on success, and >0 if  an
error occurs.

=back

