#!/usr/bin/perl
#
# Written by Martin Bartosch for the OpenXPKI project 2006
# Copyright (c) 2006 by The OpenXPKI Project
# $Revision$
#

use strict;
use warnings;
use English;
use Getopt::Long qw( :config permute pass_through );
use Pod::Usage;
use Term::ReadLine;
use File::Spec;
use Config::Std;

# use Smart::Comments;
use Data::Dumper;
use OpenXPKI::Debug;


$SIG{PIPE} = 'IGNORE';

my %params;
GetOptions(\%params,
	   qw(
	      help|?
	      man
	      socketfile=s
              session=s
              debug:s@
	      ));

pod2usage(-exitstatus => 0, -verbose => 2) if $params{man};
pod2usage(-verbose => 1) if ($params{help});

# read .openxpki/cli.conf file
my $configdir = File::Spec->catfile($ENV{HOME}, '.openxpki');
my $configfile = File::Spec->catfile($configdir, 'cli.conf');

my $config;

# only read configuration file for interactive sessions
if (scalar @ARGV == 0 && -r $configfile) {
    read_config $configfile => $config;
}

###########################################################################
# override config file with command line arguments
if (defined $params{socketfile}) {
    $config->{server}->{socketfile} = $params{socketfile};
}

if (defined $params{session}) {
    $config->{client}->{session} = $params{session};
}

###########################################################################

my @debug_entries;
# pull debug configuration from configuration file (if configured at all)
if (defined $config->{client}->{debug}) {
    if (ref $config->{client}->{debug} eq 'ARRAY') {
	@debug_entries = @{$config->{client}->{debug}};
    } else {
	@debug_entries = ( $config->{client}->{debug} );
    }
}

# override debug settings from the command line
if (defined $params{debug}) {
    @debug_entries = split(m{,}, join(',', @{$params{debug}}));
}

foreach my $param (@debug_entries) {
    my ($module, $level) = ($param =~ m{ \A (.*?):?(\d*) \z }xms);
    if ($level eq '') {
	$level = 1;
    }
    if ($module eq '') {
	$module = '.*';
    }
    print STDERR "Debug level for module '$module': $level\n";
    $OpenXPKI::Debug::LEVEL{$module} = $level;
}


require OpenXPKI::Client::CLI;

my $cli = OpenXPKI::Client::CLI->new(
    {
	SOCKETFILE => $config->{server}->{socketfile},
    });

my $response;

my %args;
if (exists $config->{client}->{session}) {
    $args{SESSION_ID} = $config->{client}->{session},
}

eval {
    $response = $cli->init_session(\%args);
};
if (my $exc = OpenXPKI::Exception->caught()) {
    if ($exc->message() eq 'I18N_OPENXPKI_CLIENT_INIT_SESSION_FAILED') {
	print STDERR "Saved session is invalid, starting a new one\n";
	$cli = undef;
	$cli = OpenXPKI::Client::CLI->new(
	    {
		SOCKETFILE => $config->{server}->{socketfile},
	    });
	$response = $cli->init_session();
    }
}
$config->{client}->{session} = $cli->get_session_id();


if (scalar @ARGV == 0) {
    print "Entering interactive OpenXPKI shell.\n";
    print "Type 'help' for help, 'quit' to exit.\n\n";

    my $term = new Term::ReadLine 'OpenXPKI';
    my $OUT = $term->OUT || \*STDOUT;
    my $state = '';

    # render first server message (as returned by init_session())
    $cli->render($response) if defined $response;

    my $exitcode = 0;
  INTERACTION:
    while (1) {
	### $cli->get_communication_state()
	# this should not happen: after initialization the client
	# should be able to send commands, and if we are re-iterating
	# the process_command() method should have handled the server
	# response
	if ($cli->get_communication_state() ne 'can_send') {
	    ### handle response from last command and render output...
	    print $OUT "ERROR: Incorrect communication state\n";
	    eval {
		$response = $cli->collect();
	    };
	    $cli->render($response) if defined $response;
	}

	# get current session status
	eval {
	    $response = $cli->send_receive_service_msg('STATUS');
	};
	if (my $exc = OpenXPKI::Exception->caught()) {
	    if ($exc->message() eq 'I18N_OPENXPKI_TRANSPORT_SIMPLE_CLIENT_READ_CLOSED_CONNECTION') {
		print $OUT "Server terminated connection.\n";
		last INTERACTION;
	    }
	} elsif ($EVAL_ERROR) {
	    print "error: $EVAL_ERROR\n";
	    next INTERACTION;
	}


	if (exists $response->{SESSION}->{ROLE}) {
	    my $user = $response->{SESSION}->{USER} || 'nobody';
	    my $role = $response->{SESSION}->{ROLE};
	    $state = "$user/$role";
	}

	my $prompt = 'OpenXPKI [' . $state . ']: ';
	my $line = $term->readline($prompt);
	last INTERACTION unless defined $line;  # accept EOF to leave shell

	my $cmd_res;
	eval {
	    $cmd_res = $cli->process_command($line, 
					     {
						 READLINE => $term,
					     }
		);
	};
	if (my $exc = OpenXPKI::Exception->caught()) {
	    if ($exc->message() eq 'I18N_OPENXPKI_TRANSPORT_SIMPLE_CLIENT_READ_CLOSED_CONNECTION') {
		print $OUT "Server terminated connection.\n";
		last INTERACTION;
	    }
	} elsif ($EVAL_ERROR) {
	    print "error: $EVAL_ERROR\n";
	    next INTERACTION;
	}

	# command exit requested?
	last INTERACTION if (! defined $cmd_res);

	$cli->render($cmd_res) if defined $cmd_res;

	my @message;
	if (exists $cmd_res->{MESSAGE}) {
	    if (ref $cmd_res->{MESSAGE} eq '') {
		push @message, $cmd_res->{MESSAGE};
	    }
	    if (ref $cmd_res->{MESSAGE} eq 'ARRAY') {
		@message = @{$cmd_res->{MESSAGE}};
	    }
	}

	if (! defined $cmd_res->{ERROR}) {# ||
	    #($cmd_res->{ERROR} == 0)) {
	    print $OUT join("\n", @message);
	    print "\n";
	} else {
	    if ($cmd_res->{ERROR} ne '0') {
		print $OUT "ERROR $cmd_res->{ERROR}: ". join("\n", @message) . "\n";
	    }
	}



	$term->addhistory($line) if ($line ne "");
    }    

    # try to write configuration    
    mkdir $configdir;
    write_config %{$config}, $configfile;
    exit $exitcode;

} else {
    die "Non-interactive use currently under construction. Stopped";

    my $res = $cli->process(join(' ', @ARGV));
    my $rc = $res->{ERROR};
    if ($res->{ERROR} == 0) {
	if (scalar @{$res->{MESSAGE}}) {
	    print join("\n", @{$res->{MESSAGE}});
	}
    } else {
	print "ERROR $res->{ERROR}: ". join("\n", @{$res->{MESSAGE}}) . "\n";
    }
    exit $rc;
}

__END__

=head1 NAME

