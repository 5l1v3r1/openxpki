<%args>
  $__session_id => undef
  $next_comp    => undef
</%args>
<%perl>
    ## next_comp is used to start a component via a normal web link
    ## somewhere on your portal after the authentication was successful
    if (!defined $next_comp) {
        $next_comp = $m->request_args()->{'next_comp'};
    }
    my $no_menu  = $m->request_args()->{'no_menu'};
    $m->comp ('/lib/debug.mhtml',
              'level' => 99,
              'msg'   => 'next_comp: ' . $next_comp
    );

    ## let's init the environment
    $m->comp('/authentication/session.mhtml',
             'init'         => 1,
             '__session_id' => $__session_id);
    my $session_id = $context->{session_id};
    my $client     = $context->{client};
    my $msg      = $client->send_receive_service_msg('PING');

    $m->comp ('/lib/debug.mhtml',
              'level' => 99,
              'msg'   => Dumper($context->{msg}));

    ## try to ping. if SERVICE_READY is returned, the connection
    ## is working and the user is logged in already
    my $ping_msg = $client->send_receive_service_msg('PING');
    if ($ping_msg->{SERVICE_MSG} eq 'SERVICE_READY') {
        print "REDIRECT_TO_SERVICE_AUTOHANDLER";
        return;
    }
    ## check the message
    if (! defined $msg &&
        $client->get_communication_state ne "can_receive" &&
        ! $client->is_connected()
    ) {
        ## let's kill the connection and start again
        $m->comp ('/lib/debug.mhtml',
                 'level' => 2,
                 'msg'   => 'starting over ...');
        delete $context->{client};
        $m->comp('/authentication/session.mhtml');
        $session_id = $context->{session_id};
        $client     = $context->{client};
        $msg        = $context->{msg} if (exists $context->{msg});
    }
    $m->comp ('/lib/debug.mhtml',
              'level' => 99,
              'msg'   => Dumper($context->{msg}));
    $m->comp ('/lib/debug.mhtml',
              'level' => 99,
              'msg'   => Dumper($context->{msg}));
    $msg = $m->comp('/authentication/pki_realm.mhtml',  'msg' => $msg);
    $m->comp ('/lib/debug.mhtml',
              'level' => 99,
              'msg'   => Dumper($context->{msg}));
    $msg = $m->comp('/authentication/auth_stack.mhtml',
            'msg' => $msg,
            'next_comp' => $next_comp,
            'no_menu'  => $no_menu,
    );
    $m->comp ('/lib/debug.mhtml',
              'level' => 99,
              'msg'   => Dumper($context->{msg}));
    $msg = $m->comp('/authentication/passwd.mhtml',
                        'msg'      => $msg,
                        'next_comp' => $next_comp,
                        'no_menu'  => $no_menu,
    );
    $m->comp ('/lib/debug.mhtml',
              'level' => 99,
              'msg'   => Dumper($context->{msg}));
    $msg = $m->comp('/authentication/x509.mhtml',
                        'msg'      => $msg,
                        'next_comp' => $next_comp,
                        'no_menu'  => $no_menu,
    );
    $m->comp ('/lib/debug.mhtml',
              'level' => 99,
              'msg'   => Dumper($context->{msg}));
    $msg = $m->comp('/authentication/sso.mhtml',
                        'msg'      => $msg,
                        'next_comp' => $next_comp,
                        'no_menu'  => $no_menu,
    );
    $m->comp ('/lib/debug.mhtml',
              'level' => 99,
              'msg'   => Dumper($context->{msg}));
    $m->comp('/authentication/role.mhtml', 'msg' => $msg);
    $m->comp ('/lib/debug.mhtml',
              'level' => 99,
              'msg'   => Dumper($context->{msg}));
    #print STDERR "session_id ::= ".$context->{session_id}."\n";

    ## msg can be undef on relaod
    if ($msg->{SERVICE_MSG} eq "SERVICE_READY" or
        not defined $msg)
    {
        print "REDIRECT_TO_SERVICE_AUTOHANDLER";
    }
    elsif ($msg->{SERVICE_MSG} eq "ERROR")
    {
        # something went wrong during the authentication ...
        # we have to delete the cookie, because otherwise one might be
        # stuck in a state of authentication from which one can not return
        # - say a user accidentally chose the 'Operator' stack. If we
        # do not delete the cookie, he will present a valid session ID
        # for a session that asks for an operator password, which the user
        # does not have ...
        my $cookies = CGI::Cookie->fetch();
        if (defined $cookies && exists $cookies->{'openxpki_sessionid'}) {
            # session ID cookie exists, we have to delete it
            # a cookie with a negative expiration date is equivalent to
            # deleting it ...
            my $c = CGI::Cookie->new(
                -name    => 'openxpki_sessionid',
                -expires => '-1M',
                -path    => '/',
            );
            $r->headers_out->set('Set-Cookie' => $c);
        }
        $m->comp ('/service/create_csr/print_errors.mhtml',
                  'errors' => [ $m->comp ('/lib/get_deep_error.mhtml', 'msg' => $msg) ]);
    }
    $m->comp ('/lib/debug.mhtml',
              'level' => 1,
              'msg'   => "authentication autohandler finished");


</%perl>
<%init>
  $r->content_type('text/html; charset=utf-8');
</%init>
<%once>
  use Data::Dumper;
</%once>
