<%args>
    $role             => undef
    $profile          => undef
    $subject_style    => undef
    $subject          => undef
    $subject_alt_name => undef
    $info             => undef
    $keygen           => undef
    $spkac            => undef
    $pkcs10           => undef
    $key              => undef
</%args>
<%init>
    ## we must know which workflow we should use for the validation
    return if (not defined $subject_style);

    ## build PARAMS
    my %params = ();

    $params{"cert_role"}             = $role             if (defined $role);
    $params{"cert_profile"}          = $profile          if (defined $profile);
    $params{"cert_subject_style"}    = $subject_style    if (defined $subject_style);
    $params{"cert_subject"}          = $subject          if (defined $subject);
    $params{"cert_subject_alt_name"} = $subject_alt_name if (defined $subject_alt_name);
    $params{"cert_info"}             = $info             if (defined $info);
    $params{"spkac"}                 = $spkac            if (defined $spkac);
    $params{"pkcs10"}                = $pkcs10           if (defined $pkcs10);
    $params{"private_key"}           = $key              if (defined $key);

    ## this type must always be set to intercept empty CSRs
    if ($spkac or $keygen eq "SPKAC")
    {
        $params{"csr_type"} = "spkac";
    } else {
        $params{"csr_type"} = "pkcs10";
    }

    ## create the workflow for the new CSR
    my $msg = $context->{client}->send_receive_command_msg (
                   "create_workflow_instance",
                   {WORKFLOW => "I18N_OPENXPKI_WF_TYPE_CERTIFICATE_SIGNING_REQUEST",
                    PARAMS   => \%params});
    my $errors = [];
    if (not ref $msg)
    {
        ## ups, this is completely unexpected
        $errors = [ [ $msg ] ];
    }
    elsif (exists $msg->{PARAMS} and
        exists $msg->{PARAMS}->{ERROR})
    {
        ## detected workflow error
        if ($msg->{PARAMS}->{ERROR}->{TYPE} eq "STACK")
        {
            $errors = $msg->{PARAMS}->{ERROR}->{STACK};
        } else {
            $errors = [ [ $msg->{PARAMS}->{ERROR}->{MESSAGE}] ];
        }
    }
    elsif (exists $msg->{ERROR})
    {
        ## general error
        if (not ref $msg->{ERROR})
        {
            ## this is CODE exception from the server !!!
            $errors = [ [ Dumper ($msg) ] ];
        }
        elsif ($msg->{ERROR}->{TYPE} eq "STACK")
        {
            $errors = $msg->{ERROR}->{STACK};
        }
        else
        {
            $errors = [ [ $msg->{ERROR}->{MESSAGE} ] ];
        }
    }
    $key = "" if (scalar @{$errors});

    ## now store the private key
    if ($key)
    {
        my $key_msg = $context->{client}->send_receive_command_msg (
                          "create_workflow_instance",
                          {WORKFLOW => "I18N_OPENXPKI_WF_TYPE_STORE_PRIVATE_KEY",
                           PARAMS   => {"private_key" => $key,
                                        "workflow_id" => $msg->{WORKFLOW}->{ID}}});
        if (exists $key_msg->{ERROR})
        {
            ## FIXME: uups, we got a real problem the CSR is in the database
            ## FIXME: but not the private key !!!
            ## FIXME: can we log this event to system.fatal ?
            if ($key_msg->{ERROR}->{TYPE} eq "STACK")
            {
                $errors = $key_msg->{ERROR}->{STACK};
            } else {
                $errors = [ [ $key_msg->{ERROR}->{MESSAGE} ] ];
            }
        }
    }

    ## handle errors
    if (scalar @{$errors})
    {
        my @list = ();
        foreach my $item (@{$errors})
        {
            push @list, [ $item->[0], %{$item->[1]} ];
        }
        return \@list;
    }

    ## this should be a serial number of the workflow
    return $msg;
</%init>
