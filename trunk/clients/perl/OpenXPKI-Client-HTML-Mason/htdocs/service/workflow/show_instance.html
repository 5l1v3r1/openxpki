<%args>
    $type => undef
    $id   => undef
    $msg  => undef
    $activities => undef
</%args>
<h1><% i18nGettext ('I18N_OPENXPKI_CLIENT_HTML_MASON_WORKFLOW_SHOW_INSTANCE_TITLE') %></h1>
<p>
  <% i18nGettext('I18N_OPENXPKI_CLIENT_HTML_MASON_WORKFLOW_SHOW_INSTANCE_DESCRIPTION') %>
</p>

%    ## I expect the following:
%    ## SERVICE_MSG => "COMMAND",
%    ## COMMAND     => $cmd,
%    ## PARAMS      => 
%    ## {
%    ##     WORKFLOW =>
%    ##     {
%    ##         ID      => $id,
%    ##         STATE   => $state,
%    ##         CONTEXT => { ... a simple hash ... }
%    ##     }
%    ## }

<table>
  <tr>
    <th><% i18nGettext('I18N_OPENXPKI_CLIENT_HTML_MASON_TABLE_HEAD_NAME') %></th>
    <th><% i18nGettext('I18N_OPENXPKI_CLIENT_HTML_MASON_TABLE_HEAD_VALUE') %></th>
  </tr>
  <tr>
    <td><% i18nGettext('I18N_OPENXPKI_CLIENT_HTML_MASON_WORKFLOW_SERIAL') %></td>
    <td><% $msg->{PARAMS}->{WORKFLOW}->{ID} %></td>
  </tr>
  <tr>
    <td><% i18nGettext('I18N_OPENXPKI_CLIENT_HTML_MASON_WORKFLOW_STATE') %></td>
    <td><% i18nGettext($msg->{PARAMS}->{WORKFLOW}->{STATE}) %></td>
  </tr>
  <tr>
    <td><% i18nGettext('I18N_OPENXPKI_CLIENT_HTML_MASON_WORKFLOW_TYPE') %></td>
    <td><% i18nGettext($msg->{PARAMS}->{WORKFLOW}->{TYPE}) %></td>
  </tr>
  <tr>
    <td><% i18nGettext('I18N_OPENXPKI_CLIENT_HTML_MASON_WORKFLOW_DESCRIPTION') %></td>
    <td><% i18nGettext($msg->{PARAMS}->{WORKFLOW}->{DESCRIPTION}) %></td>
  </tr>
  <tr>
    <td><% i18nGettext('I18N_OPENXPKI_CLIENT_HTML_MASON_WORKFLOW_LAST_UPDATE') %></td>
    <td><% $msg->{PARAMS}->{WORKFLOW}->{LAST_UPDATE} %></td>
  </tr>
% foreach my $param (sort keys %{$msg->{PARAMS}->{WORKFLOW}->{CONTEXT}})
% {
%   next if ($param eq "approvals" and length $msg->{PARAMS}->{WORKFLOW}->{CONTEXT}->{$param} == 0);
%   next if ($param eq "cert_profile_id");
%   next if ($param =~ m{ \A _ }xms); # ignore "volatile" context parameters
  <tr>
      <td>
% $m->comp('/lib/field_to_i18n.mhtml',
%          'field' => $param);
      </td>
    <td>
%   my $value = $msg->{PARAMS}->{WORKFLOW}->{CONTEXT}->{$param};
%   # someone is interpreting UTF8 data here, re-encode ...
%   # FIXME - find out why this is actually happening so that we
%   # can eliminate the source
%   $value = encode('UTF-8', $value);
%   if ($value =~ /^(ARRAY|HASH)/)
%   {
%      ## serialized stuff
%      my $ser = OpenXPKI::Serialization::Simple->new();
%      my $ref = $ser->deserialize($value);
       <pre>
%      if ($param eq "cert_info")
%      {
%          ## simple hash
%          foreach my $key (sort keys %{$ref})
%          {
<% $key %>::=<% $ref->{$key} %>
%          }
%      }
%      elsif ($param eq 'ticket') {
<ul>
%          foreach my $key (sort keys %{$ref}) {
%               my $url_msg = $context->{client}->send_receive_command_msg(
%                   "get_url_for_ticket",
%                   {
%                       "NOTIFIER" => $key,
%                       "TICKET"   => $ref->{$key}
%                   },
%               );
%               my $url = $url_msg->{PARAMS};
               <li><a href="<% $url %>"><% i18nGettext($key) %>: <% i18nGettext($ref->{$key}) %></a>
%            }
</ul>
%      }
%      elsif ($param eq "cert_subject_alt_name")
%      {
%          ## array of arrays
%          foreach my $pair (@{$ref})
%          {
%              next if (not $pair); ## empty array
<% $pair->[0] %>::=<% $pair->[1] %>
%          }
%      }
%      elsif ($param eq "approvals")
%      {
%          if (ref $ref eq 'HASH') { # old style
%              ## hash: user to role
%              foreach my $user (sort keys %{$ref})
%              {
%                  next if (not defined $user); ## empty hash - !???
<% $user %>&rarr;<% $ref->{$user} %>
%              }
%          }
%          elsif (ref $ref eq 'ARRAY') { # new style for signatures
%             foreach my $approval (@{$ref}) {
%                 if (defined $approval->{signature}) {
<% i18nGettext('I18N_OPENXPKI_SIGNED_APPROVAL') %>:
<% $approval->{signer_subject} %>&rarr;<% $approval->{signer_role} %>
<% i18nGettext('I18N_OPENXPKI_SIGNER_CERTIFICATE_IDENTIFIER') %>: <% $approval->{signer_identifier} %>
<% i18nGettext('I18N_OPENXPKI_SIGNED_TEXT') %>: <% $approval->{plaintext} %>
<% i18nGettext('I18N_OPENXPKI_SIGNATURE') %>: <% $approval->{signature} %>
%                 }
<% $approval->{session_user} %>&rarr;<% $approval->{session_role} %>

================================================================

%             }
%          }
%      }
%      else
%      {
%         my $dump = Dumper($ref);
%   Encode::_utf8_on($dump);
<% $dump %>
%      }
       </pre>
%   } elsif ($param eq "spkac") {
%      for (my $i = int(length ($value) / 64); $i > 0; $i--)
%      {
%          $value = substr ($value, 0, $i*64)."\n".substr($value,$i*64);
%      }
       <pre><% $value %></pre>
%   } elsif ($value =~ m{ \A -----BEGIN }xms) { # PKCS 10 or key
       <pre><% $value %></pre>
%   }
%   else {
       <% i18nGettext($value) %>
%   }
    </td>
  </tr>
% }
</table>
<h1><% i18nGettext ('I18N_OPENXPKI_CLIENT_HTML_MASON_WORKFLOW_SHOW_INSTANCE_ACTIVITIES') %></h1>
<div class="openxpki_command_list">
% foreach my $action (sort keys %actions)
% {
%   my $filename = lc($actions{$action});
%      $filename =~ s/i18n_openxpki_wf_[^_]*_//;
%   my $buttonname = 'I18N_OPENXPKI_WF_ACTION_' . uc($filename);
  <div class="openxpki_command_list_item">
    <& /service/open_form.mhtml, 'action' => $context->{menu}->get_root()."/service/workflow/activity/$filename.html" &>
    <& /lib/html/hidden.mhtml, 'name' => 'type', 'value' => $type &>
    <& /lib/html/hidden.mhtml, 'name' => 'id', 'value' => $id &>
    <& /lib/html/input.mhtml, 'type' => 'submit', 'value' => i18nGettext($buttonname) &>
    <& /service/close_form.mhtml &>
  </div>
% }
  <div class="openxpki_command_list_item">
    <& /service/open_form.mhtml, 'action' => $context->{menu}->get_root()."/service/workflow/get_workflow_instance_info.html" &>
    <& /lib/html/hidden.mhtml, 'name' => 'id', 'value' => $id &>
    <!-- the format is optional -->
    <& /lib/html/hidden.mhtml, 'name' => 'format', 'value' => 'png' &>
    <& /lib/html/input.mhtml, 'type' => 'submit', 'value' => i18nGettext ('I18N_OPENXPKI_HTML_GET_WORKFLOW_INSTANCE_INFO') &>
    <& /service/close_form.mhtml &>
  </div>
  <div class="openxpki_command_list_item">
    <input type="button" name="print" value="<% i18nGettext ('I18N_OPENXPKI_HTML_PRINT_BUTTON') %>" onClick="window.print()"/>
  </div>
</div>

<%once>
    use Encode qw(encode decode);
    use Data::Dumper;
    $Data::Dumper::Terse = 1;
    $Data::Dumper::Sortkeys = 1;
</%once>
<%init>
    if (not defined $msg or
        not ref $msg or
        not ref $msg eq "HASH")
    {
        if (! defined $type) {
            # type was not specified, get it from the server
            my $type_msg = $context->{client}->send_receive_command_msg(
                'get_workflow_type_for_id',
                {
                    'ID' => $id,
                },
            );
            $type = $type_msg->{PARAMS};
        }
        ## ok we have to get the info from the server
        $msg = $context->{client}->send_receive_command_msg
               (
                   "get_workflow_info",
                   {
                       "WORKFLOW" => $type,
                       "ID"       => $id
                   }
               );
    }
    else
    {
        ## sometimes we have only the message
        $id   = $msg->{PARAMS}->{WORKFLOW}->{ID}   if (not defined $id);
        $type = $msg->{PARAMS}->{WORKFLOW}->{TYPE} if (not defined $type);
    }
    if (not defined $activities)
    {
        ## ok we have to get the info from the server
        ## FIXME: this fails if type and id are undefined, id can
        ## be extracted from $msg, but what about type?
        my $hmsg = $context->{client}->send_receive_command_msg
               (
                   "get_workflow_activities",
                   {
                       "WORKFLOW" => $type,
                       "ID"       => $id
                   }
               );
        $activities = $hmsg->{PARAMS};
    }

    my %actions = ();
    foreach my $key (@{$activities})
    {
        ## I hope that nobody will translate two actions with the same string
	## Here are some translation tags for CRR activities (for pot-file)
	## "I18N_OPENXPKI_WF_ACTION_APPROVE_CRR"
	## "I18N_OPENXPKI_WF_ACTION_CANCEL_CRR_APPROVAL"
	## "I18N_OPENXPKI_WF_ACTION_CHANGE_CRR_COMPROMISE_TIME"
	## "I18N_OPENXPKI_WF_ACTION_CHANGE_CRR_REASON"
	## "I18N_OPENXPKI_WF_ACTION_REJECT_CRR"
	## "I18N_OPENXPKI_WF_ACTION_REVOKE_CERTIFICATE"
        $actions{i18nGettext($key)} = $key;
    }
</%init>
